// SPDX-License-Identifier: MIT

/*
Name: Read-Only Reentrancy Vulnerability

Description:
The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers 
to exploit the "read-only" nature of a function to make unintended changes to the contract's state. 
Specifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract 
to trigger the receive function in the ExploitContract. This is achieved by an external call 
from a secure smart contract "A" invoking the fallback() function in the attacker's contract.

Through this exploit, the attacker gains the ability to execute code within the fallback() function
against a target contract "B," which is indirectly related to contract "A." Contract "B" derives
the price of the LP token from Contract "A," making it susceptible to manipulation and unintended price changes
through the reentrancy attack.

Mitigation:
Avoid any state-changing operations within functions that are intended to be read-only.
Makerdao example:
        // This will revert if called during execution of a state-modifying pool function.
        if (nonreentrant) {
            uint256[2] calldata amounts;
            CurvePoolLike(pool).remove_liquidity(0, amounts);
        }

REF
https://twitter.com/1nf0s3cpt/status/1590622114834706432
https://chainsecurity.com/heartbreaks-curve-lp-oracles/
https://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334
https://www.youtube.com/watch?v=0fgGTRlsDxI

*/

pragma solidity ^0.8.13;

import "./interface.sol";

interface ICurve {
    function get_virtual_price() external view returns (uint256);
    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable returns (uint256);
    function remove_liquidity(uint256 lp, uint256[2] calldata min_amounts) external returns (uint256[2] memory);
    function remove_liquidity_one_coin(uint256 lp, int128 i, uint256 min_amount) external returns (uint256);
}

address constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
address constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token

contract VulnContract {
    IERC20 public constant token = IERC20(LP_TOKEN);
    ICurve public constant pool = ICurve(STETH_POOL);

    mapping(address => uint256) public balanceOf;

    function stake(uint256 amount) external {
        token.transferFrom(msg.sender, address(this), amount);
        balanceOf[msg.sender] += amount;
    }

    function unstake(uint256 amount) external {
        balanceOf[msg.sender] -= amount;
        token.transfer(msg.sender, amount);
    }

    function getReward() external view returns (uint256) {
        //rewarding tokens based on the current virtual price of the pool LP token
        uint256 reward = (balanceOf[msg.sender] * pool.get_virtual_price()) / 1e18;
        // Omitting code to transfer reward tokens
        return reward;
    }
}
